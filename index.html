<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="author" content="Yunxuan Xu (yx595@cornell.edu)" />
        <title>Fast Robot Lab Report</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <link href="css/styles.css" rel="stylesheet" />
        <!-- Set font sizes and margin styles-->
        <style>
            #sidebar-wrapper .list-group-item {font-size: 20px;font-weight: bold; padding-left: 10px;}
            .navbar-nav .nav-link {font-size: 20px;font-weight: bold;}
            .container-fluid {padding-right: 100px;}
            .lab-section {padding-right: 100px; padding-top: 70px; margin-top: -70px;padding-bottom: 200px}
            .about-me {padding-right: 100px; font-size: 22px; }
            .bold-underline {font-weight: bold; text-decoration: underline;}
            h1 {font-size: 48px;margin-bottom: 0.7em;}
            h2 {font-size: 36px;margin-top: 1em;font-weight: bold;}
            h3 {font-size: 28px;margin-top: 1em;text-align: center;}
            h4 {font-size: 24px;margin-top: 1em; bold;}
            h5 {font-size: 18px;margin-top: 1em;font-weight: normal;line-height: 1.5}
        </style>
    </head>

    <body>
        <div class="d-flex" id="wrapper">
            <!-- Sidebar-->
            <div class="border-end bg-white" id="sidebar-wrapper"
            style="position: fixed; top: 0; left: 0; bottom: 0; overflow-y: auto; width: 250px;">
                <div class="sidebar-heading border-bottom bg_light">ECE 5160 Labs</div>
                <div class="list-group list-group-flush">
                    <a class="list-group-item list-group-item-light p-3" href="#lab1">Lab 1</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab2">Lab 2</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab3">Lab 3</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab4">Lab 4</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab5">Lab 5</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab6">Lab 6</a>
                </div>
            </div>
            <!-- Page content wrapper-->
            <div id="page-content-wrapper"
            style="margin-left: 280px; margin-right: 0px;
                   padding-left: 15px; padding-right: 10px;">
                <!-- Top navigation-->
                <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom"
                style="position: fixed; top: 0; right: 0; left: 250px; z-index: 1000;">
                    <div class="container-fluid">
                        <div class="collapse navbar-collapse" id="navbarSupportedContent">
                            <ul class="navbar-nav ms-auto mt-2 mt-lg-0">
                                <li class="nav-item active"><a class="nav-link"
                                    href="#">Home</a></li>
                            </ul>
                        </div>
                    </div>
                </nav>

                <!-- Page content-->
                <div class="container-fluid">
                    <div class="pt-5">
                        <div style="padding-top: 5vh;"></div>
                        <h1>ECE 5160 - Fast Robots (2024SP)</h1>
                        <hr><h1 style="font-size: 26px;">Author: Yunxuan Xu (NetID: yx595)</h1><hr>
                        <div class="about-me">
                            <p class="bold-underline">About Me</p>
                            <div style="padding-top: 3vh;"></div>
                            <div class="text-center">
                                <img class="img-fluid" src="images/selfie.jpg"
                                alt="Yunxuan Xu" style="width:24%; height:auto;">
                            </div>
                            <div style="padding-top: 3vh;"></div>
                            <h5> I am a current M.Eng. student in ECE at Cornell Univerity. I received me B.S. in Physics
                              and B.A. in Math from Case Western Reserve University. I am interested in semiconductor
                              physics, nanofabrication and VLSI.</h5>
                        </div><hr>
                        <div style="padding-top: 10vh;"></div>
                    </div>

                    <!-- Lab 1 content -->
                    <div id="lab1" class="lab-section">
                        <h2>Lab 1: The Artemis board and Bluetooth</h2>
                        <h3>Part I: Examples on the Artemis Board</h3>
                        <h4>Objectives</h4>
                        <h5>The primary goal of this lab was to establish a foundational understanding and
                          hands-on experience with the SparkFun RedBoard Artemis Nano through a series of
                          tasks. </h5>
                        <hr>
                        <h4>1. “Example_Blink”</h4>
                        <h5>In this part of the lab, the 'Blink' sketch was uploaded to the SparkFun RedBoard Artemis Nano.
                          The onboard LED was programmed to alternate between on and off states.
                          A shown in the video, the blinking blue LED blink with 1 second delay </h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/_Sj9BUfsdPk"
                          title="Blinking LED" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>2. "Example4_Serial"</h4>
                        <h5>In this example, we interacted with the Serial Monitor functionality in the Arduino IDE.
                           As seen in the screenshot, the Serial Monitor first outputs a sequence of printed messages
                           confirming the printf capability of the board. Then it allows serial communication by sending
                           string messages to the console and echoing back any user input. When I send message
                           “Send back: Hello”, the monitor echo back the same message.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <img src="images/Lab1/p1.png" alt="Example4_Serial" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. "Example2_analogRead"</h4>
                        <h5>In this example, we will explore the Artemis Nano's temperature sensing capabilities.
                          The temperature on the chip will be detected and printed in the second column in the Serial Monitor,
                          as shown in the video. Initially, the temperature is about 32764 (32.764 Celsius). The temperature
                          readings increase to ~33244 (33.244 Celsius) when a finger is placed on the chip, indicating heat
                          transfer, and decrease to ~32900 (32.9 Celsius) when blown upon, showcasing the sensor's responsiveness
                          to temperature variations.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/GDJAb92Xd2g"
                          title="Temperature Readings" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>4. "Example1_MicrophoneOutput"</h4>
                        <h5>In this part, the Example1_MicrophoneOutput script processes audio input to identify the
                          loudest frequency component using FFT, with the results displayed in real-time via the Serial Monitor.
                          The video dynamically showcases the microphone's ability to detect and respond to frequency changes
                          produced by a frequency generator app. The frequency generated by the phone are 400Hz, 1000Hz and 900 Hz,
                          while the result shows there is a bias about 7Hz.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/8JB_lKt7qPI"
                          title="Frequency Readings" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>5000 Level: LED Response to Musical 'A' Note</h4>
                        <h5>The task uses the microphone to detect sound frequencies and activate an LED when the musical "A"
                          note (440 Hz) is identified. The screenshot confirms the Serial Monitor’s output, where frequencies
                          near 440 Hz trigger a "Yes" response. A tolerance of 10 Hz accommodates minor deviations, accounting
                          for a slight bias previously noted. The video shows the LED activation when a ~440 Hz tone is
                          generated by a frequency generator.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/YIH7t8YpTgo"
                            title="LED Response" frameborder="0" allowfullscreen></iframe>
                            <img src="images/Lab1/p2.png" alt="LED Response" style="width:35%; height:auto;">
                        </div>
                        <hr>
                        <div style="padding-top: 5vh;"></div>
                        <h3>Part II: Bluetooth Connection</h3>
                        <h4>Objectives</h4>
                        <h5>The objective of this part of the lab is to understand the BLE technology and its application in
                          connecting the Artemis board to a computer. By the end of this part, we should be able to send and
                          receive data over Bluetooth, exploring how this capability can be integrated into future labs.</h5>
                        <hr>
                        <h4>Prelab</h4>
                        <h5>The prelab setup entailed a series of steps, including the installation of Python, setting up a
                          virtual environment, and acquiring the ArduinoBLE library. After
                          'ble_arduino.ino' sketch was uploaded to the Artemis board, the Serial Monitor displayed the
                          BLE advertisement and the board's MAC address, as shown in the screenshot. Now the computer can
                          recognize the board as a Bluetooth device and establish a secure connection
                          for data exchange. The codebase facilitates Bluetooth communication between the computer
                          and the board, managing functions such as initializing the BLE connection and sending/receiving
                          data.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <img src="images/Lab1/p3.png" alt="Lab1_Prelab" style="width:30%; height:auto;">
                        </div>
                        <hr>
                        <h4>BLE Configuration</h4>
                        <h5>The first step involved updating the 'connection.yaml'
                          file with the MAC address obtained during the prelab. A new UUID was then generated using the “uuid4()”
                          function to uniquely identify the BLE service and was subsequently replaced in both the
                          'ble_arduino.ino' and the 'connection.yaml', as shown in the first two screenshots. The purpose of
                          changing UUIDs is to create a unique identifier for services and characteristics, which prevents
                          conflicts with other BLE devices and ensures secure, correct pairing.
                          The third screen shows the connetion is established in Python.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <img src="images/Lab1/p4.png" alt="BLE_Aruino_config" style="width:50%; height:auto;">
                            <img src="images/Lab1/p5.png" alt="BLE_Python_config" style="width:40%; height:auto;">
                        </div>
                        <div style="padding-top: 4vh;"></div>
                        <div class="text-center">
                            <img class="img-fluid" src="images/Lab1/p8.png"
                            alt="BLE_connected" style="width:60%; height:auto;">
                        </div>
                        <hr>
                        <h4>1. "ECHO" Command</h4>
                        <h5>Python script sends a string to the board using the "send_command" function. The Artemis, programmed
                          with a switch-case structure in its Arduino sketch to handle various commands including "ECHO", responds
                          by sending back a confirmation message. This round-trip communication is visually confirmed by
                          outputs of both the Serial Monitor and Python console, as shown in the screenshots. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p6.png" alt="Aruino_ECHO" style="width:60%; height:auto;">
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p7.png" alt="Python_ECHO" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>2. "GET_TIME_MILLIS" Command</h4>
                        <h5>Similarly, with the switch-case structure, the "GET_TIME_MILLIS" command is sent from the Python
                          script to the board to retrieve the current time in milliseconds. In the Arduino code, the "millis()"
                          function is used and the output is cast to a double data type to ensure precision in the transmitted
                          data. The codes and outputs is shown below.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <img src="images/Lab1/p9.png" alt="Aruino_Time" style="width:50%; height:auto;">
                            <img src="images/Lab1/p10.png" alt="Python_Time" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. "notification_handler" Function</h4>
                        <h5>The notification_handler function is invoked automatically whenever the  board sends data.
                          It processes the incoming byte array, extracting the time data in milliseconds. This data is then
                          converted into seconds for readability and added to an array for potential future analysis. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p11.png" alt="Notification1" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>4. Data Transfer Rate 1</h4>
                        <h5>The "GET_TIME" command, records time data points 'len' times, and at the end, calculates the
                          duration required to send 'len' data points. The last time data point sent represents the total time
                          taken for the transmission process. The Python script then calculates the effective data
                          transfer rate in bytes per millisecond. Integer value 'len' is user-defined in
                          "ble.send_command(CMD.GET_TIME, len)". Increase 'len' to improve the accuracy of the transfer
                          rate calculation. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                            <img src="images/Lab1/p12.png" alt="Arduino_rate1" style="width:45%; height:auto;">
                            <img src="images/Lab1/p13.png" alt="Python_rate1" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>5. "SEND_TIME_DATA" Command</h4>
                        <h5>In "SEND_TIME_DATA" case, the board captured timestamps and storing them in an array until
                          the max_array=20 was reached. It then transmitted each timestamp back to the computer.</h5>
                        <img src="images/Lab1/p14.png" alt="Arduino_rate_init" style="width:25%; height:auto; padding-left: 5vh;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                            <img src="images/Lab1/p15.png" alt="Arduino_array" style="width:50%; height:auto;">
                            <img src="images/Lab1/p16.png" alt="Python_array" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>6. "GET_TEMP_READINGS" Command and "notification_handler2" Function </h4>
                        <h5>The "GET_TEMP_READINGS" case, each reading is acquired using "getTempDegC()"
                          and stored with a corresponding timestamp from "millis()". The completed array is
                          then sent back to the computer in batches. On the Python side,"" notification_handler2"
                          is tasked with receiving this data, parsing the time and temperature values, and appending
                          them to their respective lists.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 5px;">
                            <img src="images/Lab1/p17.png" alt="Arduino_time_temp" style="width:45%; height:auto;">
                            <img src="images/Lab1/p18.png" alt="Python_time_temp" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>7. Data Tranfer Rate 2</h4>
                        <h5>In "GET_TEMP_READINGS" command, the total process time required to store data into array
                          and send array is calculated. This process time is stored in the last row of time_array and
                          be sent as the last time data point. The Python script can then calculate the effective data
                          transfer rate. As shown in the screenshot below the effective data transfer rate is ~1.041
                          bytes/ms, which is greater than 0.489 bytes/ms we get in task 4 “Data Transfer Rate 1”.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p19.png" alt="Python_rate2" style="width:60%; height:auto;">
                        </div>
                        <h5>The faster rate of 1.041 bytes/ms comes from storing multiple
                          readings in an array before sending, which reduces overhead and increases efficiency.
                          Conversely, the slower rate of 0.489 bytes/ms is due to sending
                          each reading immediately after it's taken, which includes more communication overhead for
                          each individual transmission.</h5>
                        <h5>Given that doubles occupy 8 bytes and floats occupy 4 bytes, each time-temperature pair
                          constitutes 12 bytes. Furthermore, string representations like 'T:294649.0|C:23.412' require
                          an additional 19 bytes for ‘tx_estring_value’ before sending it. Therefore, ignoring the
                          memory overhead, subtracting this string size from the total available memory (384 KB) and
                          dividing by the size per data pair gives a rough estimate of how many pairs can be stored.
                          (384000-19)/12 ≈ 31998 time-temperature pairs can be stored.</h5>
                        <hr>
                        <h4>5000 Level: Effective Data Rate and Overhead</h4>
                        <h5>The "CALC_DATA_RATE" command in the Arduino sketch send back a specified number of 'A'
                          characters, as a measure of the bytes of data transmitted over BLE within a certain timeframe.
                          In Python script, data rates were calculated based on the duration taken for replies ranging
                          from 5 bytes to 120 bytes. The observed data rates plotted against the message sizes indicate
                          a general increase in data rate with larger packets, suggesting better efficiency with fewer
                          packets. The sudden drop seen in the plot for the largest packet size could indicate a limit
                          to this efficiency gain at higher data loads.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p20.png" alt="Arduino_rate" style="width:40%; height:auto;">
                          <img src="images/Lab1/p21.png" alt="Python_rate" style="width:40%; height:auto;">
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p22.png" alt="Arduino_rate_plot" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>5000 Level: Reliability</h4>
                        <h5>By successfully sending and confirming the receipt of large data packets – 130, 140, and 150
                          bytes – with no loss, the computer demonstrates its ability to accurately read all data published
                          by the Artemis board, as shown in the screenshot. This suggests high reliability in the BLE
                          communication channel, as even when approaching the byte size limit of 151 bytes, the data
                          integrity is maintained without any observed loss or missed information. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p23.png" alt="Reliability" style="width:80%; height:auto;">
                        </div>
                        <hr>
                        <h2>Dicussion</h2>
                        <h5>Throughout this lab, I've gained a deeper understanding of BLE communication, learning how varying
                          data packet sizes affect transfer rates. One significant challenge was adapting the notification handler
                          function for various data sizes, leading to the creation of "notification_handler2", capable of processing
                          multiple data types. Implementing this handlers function for data processing is important for future labs.</h5>
                        <hr>
                    </div>

                    <!-- Lab 2 content -->
                    <div id="lab2" class="lab-section">
                        <h2>Lab 2: IMU</h2>
                        <h4>Objectives</h4>
                        <h5>The objective is to deepen the understanding of integrating sensors with robotics, focusing on an
                          Inertial Measurement Unit (IMU) and managing autonomous power via a battery. This lab aim to implement the
                          IMU with an RC car, utilizing the sensor data to analyze a dynamic stunt. </h5><hr>
                        <h4>1. Set Up the IMU</h4>
                        <h5>As shown in the first picture below, the IMU connected
                          via the red cross-shaped QWIIC connectors to the Artemis board on the right.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p1.png" alt="IMU_connection" style="width:40%; height:auto;">
                        </div>
                        <h5>The AD0_VAL defines the last bit of the I2C address for the IMU sensor. Here,
                          the AD0_VAL is set to 0, as shown in the code snippet, to succesfully initialize
                          the sensor. AD0_VAL of 1 will not work. The screenshot also illustrates the successful
                          compilation and output of the Example1_Basics.ino sketch, where the serial monitor displays
                          real-time sensor data outputs, including scaled acceleration, gyroscope, and magnetometer readings
                          in x-, y- and z-axis, as well as the temperature readings. This complete set of readings confirms
                          the IMU is connected with the Artemis.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p2.png" alt="AD0" style="width:80%; height:auto;">
                        </div>
                        <h5>I create the “Accelerometer.ino” program to visualize the sensor data through the Serial Plotter,
                          which has value 2, 3, and 4 corresponding to the x-, y-, and z-axis accelerometer readings, and value
                          5, 6, and 7 corresponding to the x-, y-, and z-axis gyroscope readings. When the IMU flat on the table,
                          the Serial Plotter shows overlapping x and y-axis accelerometer readings, as shown in screenshot below.
                          This overlapping is expected due to gravity's effect primarily on the z-axis in this position. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p3.png" alt="Plot_flat" style="width:50%; height:auto;">
                        </div>
                        <h5>Upon rotating the IMU along the cable axis, the accelerometer data, as seen in the left picture,
                          exhibits noticeable fluctuations. This noise is attributed to the accelerometer's high sensitivity
                          to even minor movements. In contrast, the gyroscope readings, depicted in the right picture, are
                          smoother. This smoothness is expected as gyroscopes measure rotation without the influence of
                          gravitational acceleration. However, the gyroscope is subject to drift over time, which can lead to
                          accumulating errors and a shift in the baseline, as suggested by the trend in the y-axis magnitude.
                          This phenomenon underscores the importance of combining accelerometer and gyroscope data for more
                          accurate motion tracking.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p4.png" alt="Plot_rot_acc" style="width:45%; height:auto;">
                          <img src="images/Lab2/p5.png" alt="Plot_rot_gyro" style="width:45%; height:auto;">
                        </div>
                        <h5>The visual indication, blinking built-in LED three times, is implemented. The blink function is
                          shown in code snippet below. And the function "pinMode(LED_BUILTIN, OUTPUT)"" and "blink(3)"" are
                          called within the setup to execute the blink pattern three times after the board initialization.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p7.png" alt="visual_indication" style="width:45%; height:auto;">
                          <img src="images/Lab2/p6.png" alt="blink" style="width:25%; height:auto;">
                        </div>
                        <hr>
                        <h4>2. Accelerometer</h4>
                        <h5>The left picture shows the equation used to calculate the pitch and roll angles from accelerometer
                          readings, while the right picture shows the code snippet that prints these angles out. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p9.png" alt="pitch_roll_eqn" style="width:15%; height:auto;">
                          <img src="images/Lab2/p8.png" alt="pitch_roll_code" style="width:45%; height:auto;">
                        </div>
                        <h5>The angle data is then processed in Python script for visualization. As shown in the two plots below,
                          a clear pattern of change in pitch and roll angles from -90 to 0 to 90 degrees. Notably, as one angle
                          reaches its extremities, the data for the other angle becomes more variable. This is due to the
                          inherent limitations of accelerometers at extreme tilt angles. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p10.png" alt="acc_pitch_degree" style="width:45%; height:auto;">
                          <img src="images/Lab2/p11.png" alt="acc_roll_degree" style="width:45%; height:auto;">
                        </div>
                        <h5>The code snippet below shows that the conversion factors of 1.038 for roll and 1.027 for pitch were
                          obtained through a two-point calibration process, indicating the high precision of the sensor after
                          calibration. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p12.png" alt="conversion_factor" style="width:45%; height:auto;">
                        </div>
                        <h5>The graph below presents the amplitude of frequencies detected in the data, with both pitch and
                          roll showing significant components at low frequencies. This suggests that the most substantial
                          movements picked up by the accelerometer occur at or below 1 Hz.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p13.png" alt="frquency_spec" style="width:45%; height:auto;">
                        </div>
                        <h5>A cut-off frequency of 1 Hz is chosen based on this analysis. By applying a low-pass filter with
                          this cut-off, we obtain the filtered signals shown in the following graph. The comparison between
                          raw and filtered data indicates that the high-frequency noise is significantly reduced, resulting
                          in smoother and more interpretable curves. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p14.png" alt="noise_filter" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. Gyroscope</h4>
                        <h5>The pitch, roll and yaw in degree is calculated using the code snippet below.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p15.png" alt="pitch_roll_gyro_eqn" style="width:30%; height:auto;">
                        </div>
                        <h5>The following two plots are from the readings of gyroscope(left) and accelerometer(right)
                          when the sensor is stationary. The left plot illustrates the sensor's drift over time, showing
                          slight deviations. This highlights the inherent drift characteristic of gyroscopes, requiring
                          periodic recalibration to correct for this drift over time.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p16.png" alt="gyro_drift" style="width:45%; height:auto;">
                          <img src="images/Lab2/p17.png" alt="acc_drift" style="width:45%; height:auto;">
                        </div>
                        <h5>The analysis of the gyroscope data when the IMU is randomly shaken shows a significant difference
                          in sensitivity between the accelerometer and the gyroscope. The gyroscope readings, represented by
                          the blue, pink, and ywllow curves, are less affected by the high-frequency noise that the accelerometer
                          readings (green and orange) pick up.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p18.png" alt="shake" style="width:50%; height:auto;">
                        </div>
                        <h5>The following two plots demonstrate that while the patterns of motion recorded by the gyroscope are
                          similar to those of the accelerometer, there is a discrepancy in magnitude. This suggests that the
                          gyroscope is better at capturing consistent rotational velocities but may require scaling or
                          calibration to match the exact motion.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p19.png" alt="acc" style="width:45%; height:auto;">
                          <img src="images/Lab2/p20.png" alt="gyro" style="width:45%; height:auto;">
                        </div>
                        <h5>The variation in smoothness between the two sets of gyroscopic data is attributed to the difference in
                          sampling rates. The left graph with a 30ms delay between samples shows a smoother curve, while the
                          second graph with a 300ms delay exhibits a rougher appearance. Thus, high sample rate is important for
                          accuracy.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p22.png" alt="fast_rate" style="width:45%; height:auto;">
                          <img src="images/Lab2/p23.png" alt="low_rate" style="width:45%; height:auto;">
                        </div>
                        <h5>Applying the complimentary filter as shown below integrates the gyroscopic and accelerometer data to
                          correct for the gyroscope's drift and the accelerometer's high sensitivity to immediate movements.
                          The weight of 0.1 in the complimentary filter effectively combines the stability of the gyroscope
                          with the accelerometer's precision. As shown in the plot on the right, both low-pass filter and the
                          complimentary filter effectively reduce the noise. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p21.png" alt="compli_filter" style="width:40%; height:auto;">
                          <img src="images/Lab2/p24.png" alt="filter_compare" style="width:50%; height:auto;">
                        </div>
                        <h5>The conversion factor of 1.044 and 1.021 indicate the data's accuracy post-filtering.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p25.png" alt="compli_cf" style="width:40%; height:auto;">
                        </div>
                        <hr>





                        <h4></h4>
                        <h5></h5>
                    </div>

                    <!-- Lab 3 content -->
                    <div id="lab3" class="lab-section">
                        <h2>Lab 3</h2>
                        <p>Content for Lab 3...</p>
                        <!-- ... more content for Lab 3 ... -->
                    </div>

                    <div id="lab4" class="lab-section">
                        <h2>Lab 4</h2>
                        <p>Content for Lab 4...</p>
                        <!-- ... more content for Lab 4 ... -->
                    </div>

                    <div id="lab5" class="lab-section">
                        <h2>Lab 5</h2>
                        <p>Content for Lab 5...</p>
                        <!-- ... more content for Lab 5 ... -->
                    </div>

                    <div id="lab6" class="lab-section">
                        <h2>Lab 6</h2>
                        <p>Content for Lab 6...</p>
                        <!-- ... more content for Lab 6 ... -->
                    </div>
                </div>
            </div>
        </div>
        <script
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js">
        </script>
        <script src="js/scripts.js"></script>
    </body>
</html>
