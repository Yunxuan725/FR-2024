<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="author" content="Yunxuan Xu (yx595@cornell.edu)" />
        <title>Fast Robot Lab Report</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <link href="css/styles.css" rel="stylesheet" />
        <!-- Set font sizes and margin styles-->
        <style>
            #sidebar-wrapper .list-group-item {font-size: 20px;font-weight: bold; padding-left: 10px;}
            .navbar-nav .nav-link {font-size: 20px;font-weight: bold;}
            .container-fluid {padding-right: 100px;}
            .lab-section {padding-right: 100px; padding-top: 70px; margin-top: -70px;padding-bottom: 200px}
            .about-me {padding-right: 100px; font-size: 22px; }
            .bold-underline {font-weight: bold; text-decoration: underline;}
            h1 {font-size: 48px;margin-bottom: 0.7em;}
            h2 {font-size: 36px;margin-top: 1em;font-weight: bold;}
            h3 {font-size: 28px;margin-top: 1em;text-align: center;}
            h4 {font-size: 24px;margin-top: 1em; bold;}
            h5 {font-size: 18px;margin-top: 1em;font-weight: normal;line-height: 1.5}
        </style>
    </head>

    <body>
        <div class="d-flex" id="wrapper">
            <!-- Sidebar-->
            <div class="border-end bg-white" id="sidebar-wrapper"
            style="position: fixed; top: 0; left: 0; bottom: 0; overflow-y: auto; width: 250px;">
                <div class="sidebar-heading border-bottom bg_light">ECE 5160 Labs</div>
                <div class="list-group list-group-flush">
                    <a class="list-group-item list-group-item-light p-3" href="#lab1">Lab 1</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab2">Lab 2</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab3">Lab 3</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab4">Lab 4</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab5">Lab 5</a>
                    <a class="list-group-item list-group-item-light p-3" href="#lab6">Lab 6</a>
                </div>
            </div>
            <!-- Page content wrapper-->
            <div id="page-content-wrapper"
            style="margin-left: 280px; margin-right: 0px;
                   padding-left: 15px; padding-right: 10px;">
                <!-- Top navigation-->
                <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom"
                style="position: fixed; top: 0; right: 0; left: 250px; z-index: 1000;">
                    <div class="container-fluid">
                        <div class="collapse navbar-collapse" id="navbarSupportedContent">
                            <ul class="navbar-nav ms-auto mt-2 mt-lg-0">
                                <li class="nav-item active"><a class="nav-link"
                                    href="#">Home</a></li>
                            </ul>
                        </div>
                    </div>
                </nav>

                <!-- Page content-->
                <div class="container-fluid">
                    <div class="pt-5">
                        <div style="padding-top: 5vh;"></div>
                        <h1>ECE 5160 - Fast Robots (2024SP)</h1>
                        <hr><h1 style="font-size: 26px;">Author: Yunxuan Xu (NetID: yx595)</h1><hr>
                        <div class="about-me">
                            <p class="bold-underline">About Me</p>
                            <div style="padding-top: 3vh;"></div>
                            <div class="text-center">
                                <img class="img-fluid" src="images/selfie.jpg"
                                alt="Yunxuan Xu" style="width:24%; height:auto;">
                            </div>
                            <div style="padding-top: 3vh;"></div>
                            <h5> I am a current M.Eng. student in ECE at Cornell Univerity. I received me B.S. in Physics
                              and B.A. in Math from Case Western Reserve University. I am interested in semiconductor
                              physics, nanofabrication and VLSI.</h5>
                        </div><hr>
                        <div style="padding-top: 10vh;"></div>
                    </div>

                    <!-- Lab 1 content -->
                    <div id="lab1" class="lab-section">
                        <h2>Lab 1: The Artemis board and Bluetooth</h2>
                        <h3>Part I: Examples on the Artemis Board</h3>
                        <h4>Objectives</h4>
                        <h5>The primary goal of this lab was to establish a foundational understanding and
                          hands-on experience with the SparkFun RedBoard Artemis Nano through a series of
                          tasks. </h5>
                        <hr>
                        <h4>1. “Example_Blink”</h4>
                        <h5>In this part of the lab, the 'Blink' sketch was uploaded to the SparkFun RedBoard Artemis Nano.
                          The onboard LED was programmed to alternate between on and off states.
                          A shown in the video, the blinking blue LED blink with 1 second delay </h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/_Sj9BUfsdPk"
                          title="Blinking LED" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>2. "Example4_Serial"</h4>
                        <h5>In this example, we interacted with the Serial Monitor functionality in the Arduino IDE.
                           As seen in the screenshot, the Serial Monitor first outputs a sequence of printed messages
                           confirming the printf capability of the board. Then it allows serial communication by sending
                           string messages to the console and echoing back any user input. When I send message
                           “Send back: Hello”, the monitor echo back the same message.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <img src="images/Lab1/p1.png" alt="Example4_Serial" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. "Example2_analogRead"</h4>
                        <h5>In this example, we will explore the Artemis Nano's temperature sensing capabilities.
                          The temperature on the chip will be detected and printed in the second column in the Serial Monitor,
                          as shown in the video. Initially, the temperature is about 32764 (32.764 Celsius). The temperature
                          readings increase to ~33244 (33.244 Celsius) when a finger is placed on the chip, indicating heat
                          transfer, and decrease to ~32900 (32.9 Celsius) when blown upon, showcasing the sensor's responsiveness
                          to temperature variations.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/GDJAb92Xd2g"
                          title="Temperature Readings" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>4. "Example1_MicrophoneOutput"</h4>
                        <h5>In this part, the Example1_MicrophoneOutput script processes audio input to identify the
                          loudest frequency component using FFT, with the results displayed in real-time via the Serial Monitor.
                          The video dynamically showcases the microphone's ability to detect and respond to frequency changes
                          produced by a frequency generator app. The frequency generated by the phone are 400Hz, 1000Hz and 900 Hz,
                          while the result shows there is a bias about 7Hz.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/8JB_lKt7qPI"
                          title="Frequency Readings" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                        <h4>5000 Level: LED Response to Musical 'A' Note</h4>
                        <h5>The task uses the microphone to detect sound frequencies and activate an LED when the musical "A"
                          note (440 Hz) is identified. The screenshot confirms the Serial Monitor’s output, where frequencies
                          near 440 Hz trigger a "Yes" response. A tolerance of 10 Hz accommodates minor deviations, accounting
                          for a slight bias previously noted. The video shows the LED activation when a ~440 Hz tone is
                          generated by a frequency generator.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/YIH7t8YpTgo"
                            title="LED Response" frameborder="0" allowfullscreen></iframe>
                            <img src="images/Lab1/p2.png" alt="LED Response" style="width:35%; height:auto;">
                        </div>
                        <hr>
                        <div style="padding-top: 5vh;"></div>
                        <h3>Part II: Bluetooth Connection</h3>
                        <h4>Objectives</h4>
                        <h5>The objective of this part of the lab is to understand the BLE technology and its application in
                          connecting the Artemis board to a computer. By the end of this part, we should be able to send and
                          receive data over Bluetooth, exploring how this capability can be integrated into future labs.</h5>
                        <hr>
                        <h4>Prelab</h4>
                        <h5>The prelab setup entailed a series of steps, including the installation of Python, setting up a
                          virtual environment, and acquiring the ArduinoBLE library. After
                          'ble_arduino.ino' sketch was uploaded to the Artemis board, the Serial Monitor displayed the
                          BLE advertisement and the board's MAC address, as shown in the screenshot. Now the computer can
                          recognize the board as a Bluetooth device and establish a secure connection
                          for data exchange. The codebase facilitates Bluetooth communication between the computer
                          and the board, managing functions such as initializing the BLE connection and sending/receiving
                          data.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <img src="images/Lab1/p3.png" alt="Lab1_Prelab" style="width:30%; height:auto;">
                        </div>
                        <hr>
                        <h4>BLE Configuration</h4>
                        <h5>The first step involved updating the 'connection.yaml'
                          file with the MAC address obtained during the prelab. A new UUID was then generated using the “uuid4()”
                          function to uniquely identify the BLE service and was subsequently replaced in both the
                          'ble_arduino.ino' and the 'connection.yaml', as shown in the first two screenshots. The purpose of
                          changing UUIDs is to create a unique identifier for services and characteristics, which prevents
                          conflicts with other BLE devices and ensures secure, correct pairing.
                          The third screen shows the connetion is established in Python.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <img src="images/Lab1/p4.png" alt="BLE_Aruino_config" style="width:50%; height:auto;">
                            <img src="images/Lab1/p5.png" alt="BLE_Python_config" style="width:40%; height:auto;">
                        </div>
                        <div style="padding-top: 4vh;"></div>
                        <div class="text-center">
                            <img class="img-fluid" src="images/Lab1/p8.png"
                            alt="BLE_connected" style="width:60%; height:auto;">
                        </div>
                        <hr>
                        <h4>1. "ECHO" Command</h4>
                        <h5>Python script sends a string to the board using the "send_command" function. The Artemis, programmed
                          with a switch-case structure in its Arduino sketch to handle various commands including "ECHO", responds
                          by sending back a confirmation message. This round-trip communication is visually confirmed by
                          outputs of both the Serial Monitor and Python console, as shown in the screenshots. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p6.png" alt="Aruino_ECHO" style="width:60%; height:auto;">
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p7.png" alt="Python_ECHO" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>2. "GET_TIME_MILLIS" Command</h4>
                        <h5>Similarly, with the switch-case structure, the "GET_TIME_MILLIS" command is sent from the Python
                          script to the board to retrieve the current time in milliseconds. In the Arduino code, the "millis()"
                          function is used and the output is cast to a double data type to ensure precision in the transmitted
                          data. The codes and outputs is shown below.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                            <img src="images/Lab1/p9.png" alt="Aruino_Time" style="width:50%; height:auto;">
                            <img src="images/Lab1/p10.png" alt="Python_Time" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. "notification_handler" Function</h4>
                        <h5>The notification_handler function is invoked automatically whenever the  board sends data.
                          It processes the incoming byte array, extracting the time data in milliseconds. This data is then
                          converted into seconds for readability and added to an array for potential future analysis. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p11.png" alt="Notification1" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>4. Data Transfer Rate 1</h4>
                        <h5>The "GET_TIME" command, records time data points 'len' times, and at the end, calculates the
                          duration required to send 'len' data points. The last time data point sent represents the total time
                          taken for the transmission process. The Python script then calculates the effective data
                          transfer rate in bytes per millisecond. Integer value 'len' is user-defined in
                          "ble.send_command(CMD.GET_TIME, len)". Increase 'len' to improve the accuracy of the transfer
                          rate calculation. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                            <img src="images/Lab1/p12.png" alt="Arduino_rate1" style="width:45%; height:auto;">
                            <img src="images/Lab1/p13.png" alt="Python_rate1" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>5. "SEND_TIME_DATA" Command</h4>
                        <h5>In "SEND_TIME_DATA" case, the board captured timestamps and storing them in an array until
                          the max_array=20 was reached. It then transmitted each timestamp back to the computer.</h5>
                        <img src="images/Lab1/p14.png" alt="Arduino_rate_init" style="width:25%; height:auto; padding-left: 5vh;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                            <img src="images/Lab1/p15.png" alt="Arduino_array" style="width:50%; height:auto;">
                            <img src="images/Lab1/p16.png" alt="Python_array" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>6. "GET_TEMP_READINGS" Command and "notification_handler2" Function </h4>
                        <h5>The "GET_TEMP_READINGS" case, each reading is acquired using "getTempDegC()"
                          and stored with a corresponding timestamp from "millis()". The completed array is
                          then sent back to the computer in batches. On the Python side,"" notification_handler2"
                          is tasked with receiving this data, parsing the time and temperature values, and appending
                          them to their respective lists.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 5px;">
                            <img src="images/Lab1/p17.png" alt="Arduino_time_temp" style="width:45%; height:auto;">
                            <img src="images/Lab1/p18.png" alt="Python_time_temp" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>7. Data Tranfer Rate 2</h4>
                        <h5>In "GET_TEMP_READINGS" command, the total process time required to store data into array
                          and send array is calculated. This process time is stored in the last row of time_array and
                          be sent as the last time data point. The Python script can then calculate the effective data
                          transfer rate. As shown in the screenshot below the effective data transfer rate is ~1.041
                          bytes/ms, which is greater than 0.489 bytes/ms we get in task 4 “Data Transfer Rate 1”.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 50px;">
                          <img src="images/Lab1/p19.png" alt="Python_rate2" style="width:60%; height:auto;">
                        </div>
                        <h5>The faster rate of 1.041 bytes/ms comes from storing multiple
                          readings in an array before sending, which reduces overhead and increases efficiency.
                          Conversely, the slower rate of 0.489 bytes/ms is due to sending
                          each reading immediately after it's taken, which includes more communication overhead for
                          each individual transmission.</h5>
                        <h5>Given that doubles occupy 8 bytes and floats occupy 4 bytes, each time-temperature pair
                          constitutes 12 bytes. Furthermore, string representations like 'T:294649.0|C:23.412' require
                          an additional 19 bytes for ‘tx_estring_value’ before sending it. Therefore, ignoring the
                          memory overhead, subtracting this string size from the total available memory (384 KB) and
                          dividing by the size per data pair gives a rough estimate of how many pairs can be stored.
                          (384000-19)/12 ≈ 31998 time-temperature pairs can be stored.</h5>
                        <hr>
                        <h4>5000 Level: Effective Data Rate and Overhead</h4>
                        <h5>The "CALC_DATA_RATE" command in the Arduino sketch send back a specified number of 'A'
                          characters, as a measure of the bytes of data transmitted over BLE within a certain timeframe.
                          In Python script, data rates were calculated based on the duration taken for replies ranging
                          from 5 bytes to 120 bytes. The observed data rates plotted against the message sizes indicate
                          a general increase in data rate with larger packets, suggesting better efficiency with fewer
                          packets. The sudden drop seen in the plot for the largest packet size could indicate a limit
                          to this efficiency gain at higher data loads.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p20.png" alt="Arduino_rate" style="width:40%; height:auto;">
                          <img src="images/Lab1/p21.png" alt="Python_rate" style="width:40%; height:auto;">
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p22.png" alt="Arduino_rate_plot" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>5000 Level: Reliability</h4>
                        <h5>By successfully sending and confirming the receipt of large data packets – 130, 140, and 150
                          bytes – with no loss, the computer demonstrates its ability to accurately read all data published
                          by the Artemis board, as shown in the screenshot. This suggests high reliability in the BLE
                          communication channel, as even when approaching the byte size limit of 151 bytes, the data
                          integrity is maintained without any observed loss or missed information. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab1/p23.png" alt="Reliability" style="width:80%; height:auto;">
                        </div>
                        <hr>
                        <h2>Dicussion</h2>
                        <h5>Throughout this lab, I've gained a deeper understanding of BLE communication, learning how varying
                          data packet sizes affect transfer rates. One significant challenge was adapting the notification handler
                          function for various data sizes, leading to the creation of "notification_handler2", capable of processing
                          multiple data types. Implementing this handlers function for data processing is important for future labs.</h5>
                        <hr>
                    </div>

                    <!-- Lab 2 content -->
                    <div id="lab2" class="lab-section">
                        <h2>Lab 2: IMU</h2>
                        <h4>Objectives</h4>
                        <h5>The objective is to deepen the understanding of integrating sensors with robotics, focusing on an
                          Inertial Measurement Unit (IMU) and managing autonomous power via a battery. This lab aim to implement the
                          IMU with an RC car, utilizing the sensor data to analyze a dynamic stunt. </h5><hr>
                        <h4>1. Set Up the IMU</h4>
                        <h5>As shown in the first picture below, the IMU connected
                          via the red cross-shaped QWIIC connectors to the Artemis board on the right.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p1.png" alt="IMU_connection" style="width:40%; height:auto;">
                        </div>
                        <h5>The AD0_VAL defines the last bit of the I2C address for the IMU sensor. Here
                          the AD0_VAL is set to 0 to initialize
                          the sensor. The screenshot illustrates the successful
                          compilation and output of the Example1_Basics.ino sketch.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p2.png" alt="AD0" style="width:80%; height:auto;">
                        </div>
                        <h5>When the IMU lies flat on the table,
                          the plot shows overlapping x- and y-axis accelerometer readings (value 2 and 3).
                          This overlapping is expected due to gravity's effect primarily on the z-axis in this position. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p3.png" alt="Plot_flat" style="width:50%; height:auto;">
                        </div>
                        <h5>Upon rotating the IMU along the cable axis, the accelerometer data in the left plot
                          exhibits noticeable fluctuations, indicating the accelerometer's high sensitivity
                          to even minor movements. In contrast, the gyroscope readings in the right plot are
                          smoother. This smoothness is expected as gyroscopes measure rotation without the influence of
                          gravity. However, the gyroscope is subject to drift over time, which can lead to
                          accumulating errors and a shift in the baseline.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p4.png" alt="Plot_rot_acc" style="width:45%; height:auto;">
                          <img src="images/Lab2/p5.png" alt="Plot_rot_gyro" style="width:45%; height:auto;">
                        </div>
                        <h5>The visual indication, blinking LED three times, is implemented after the board initialization.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p7.png" alt="visual_indication" style="width:45%; height:auto;">
                          <img src="images/Lab2/p6.png" alt="blink" style="width:25%; height:auto;">
                        </div>
                        <hr>
                        <h4>2. Accelerometer</h4>
                        <h5>The following two pictures shows the equations and codes used to calculate the pitch and roll angles
                          from accelerometer readings. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p9.png" alt="pitch_roll_eqn" style="width:15%; height:auto;">
                          <img src="images/Lab2/p8.png" alt="pitch_roll_code" style="width:45%; height:auto;">
                        </div>
                        <h5>As shown in the two plots below,
                          a clear pattern of change in pitch and roll angles from -90 to 0 to 90 degrees. As one angle
                          reaches its extremities, the other angle becomes more variable. This is due to the
                          inherent limitations of accelerometers at extreme tilt angles. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p10.png" alt="acc_pitch_degree" style="width:45%; height:auto;">
                          <img src="images/Lab2/p11.png" alt="acc_roll_degree" style="width:45%; height:auto;">
                        </div>
                        <h5>The code snippet below shows that the conversion factors of 1.038 for roll and 1.027 for pitch were
                          obtained through a two-point calibration process, indicating the high accuracy. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p12.png" alt="conversion_factor" style="width:45%; height:auto;">
                        </div>
                        <h5>The graph below is the pitch and
                          roll data in frequency domain,suggesting that the most substantial
                          movements picked up by the accelerometer occur below 1 Hz.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p13.png" alt="frquency_spec" style="width:45%; height:auto;">
                        </div>
                        <h5>A cut-off frequency of 1 Hz is then chosen. By applying a low-pass filter, we obtain the filtered
                          signals. The comparison between
                          raw and filtered data indicates the high-frequency noise is filtered, resulting
                          in smoother curves. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p14.png" alt="noise_filter" style="width:50%; height:auto;">
                        </div>
                        <hr>
                        <h4>3. Gyroscope</h4>
                        <h5>The pitch, roll and yaw in degree is calculated using the codes below.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p15.png" alt="pitch_roll_gyro_eqn" style="width:30%; height:auto;">
                        </div>
                        <h5>The following two plots are from the readings of gyroscope(left) and accelerometer(right)
                          when the IMU is stationary. The left plot illustrates the inherent drift characteristic of gyroscopes.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p16.png" alt="gyro_drift" style="width:45%; height:auto;">
                          <img src="images/Lab2/p17.png" alt="acc_drift" style="width:45%; height:auto;">
                        </div>
                        <h5>When the IMU is randomly shaken, the gyroscope readings, represented by
                          the blue, pink, and yellow curves, are less affected by the high-frequency noise that the accelerometer
                          readings (green and orange) pick up.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p18.png" alt="shake" style="width:50%; height:auto;">
                        </div>
                        <h5>The following two plots demonstrate that while the patterns of motion recorded by the gyroscope are
                          similar to those of the accelerometer, there is a discrepancy in magnitude. This suggests that the
                          gyroscope is better at capturing consistent rotational velocities but may require
                          calibration to match the exact motion.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p19.png" alt="acc" style="width:45%; height:auto;">
                          <img src="images/Lab2/p20.png" alt="gyro" style="width:45%; height:auto;">
                        </div>
                        <h5>The curves in left plot with a 30ms delay between samples is smoother than the curves in
                          the right plotwith a 300ms delay. Thus, a higher sample rate is important for
                          accuracy of gyroscopic data.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                          <img src="images/Lab2/p22.png" alt="fast_rate" style="width:45%; height:auto;">
                          <img src="images/Lab2/p23.png" alt="low_rate" style="width:45%; height:auto;">
                        </div>
                        <h5>Applying the complimentary filter as shown below integrates the gyroscopic and accelerometer data to
                          correct for the gyroscope's drift and the accelerometer's high sensitivity to immediate movements.
                          The weight of 0.1 in the complimentary filter effectively combines the stability of the gyroscope
                          with the accelerometer's precision. As shown in the plot on the right, both low-pass filter and the
                          complimentary filter effectively reduce the noise. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p21.png" alt="compli_filter" style="width:40%; height:auto;">
                          <img src="images/Lab2/p24.png" alt="filter_compare" style="width:50%; height:auto;">
                        </div>
                        <h5>The conversion factor of 1.044 and 1.021 indicate the data's accuracy post-filtering.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                          <img src="images/Lab2/p25.png" alt="compli_cf" style="width:40%; height:auto;">
                        </div>
                        <hr>
                        <h4>4. Sample Data</h4>
                        <h5>In managing the IMU data collection and transmission, two flags, 'isCollectingData' and
                          'isSendingData', are used. The 'isCollectingData' flag toggles the reading and storage of data within
                          the "save_IMU" function, while the 'isSendingData'
                          flag controls the sending of stored data arrays. This system incorporates flexibility;
                          a new incoming command from the Python can interrupt and stop the ongoing
                          GET_IMU_DATA operation by toggling these flags. This Arduino program is designed to read and send IMU data
                          for a certain time interval.</h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p26.png" alt="IMU_code1" style="width:45%; height:auto;">
                          <img src="images/Lab2/p27.png" alt="IMU_code2" style="width:50%; height:auto;">
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p28.png" alt="IMU_code3" style="width:45%; height:auto;">
                          <img src="images/Lab2/p29.png" alt="IMU_code4" style="width:50%; height:auto;">
                        </div>
                        <h5>The following Python code processes the receieved data to calculate the sample rate.
                          310 samples are collected per second over a nearly
                          5-second interval. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p30.png" alt="Python_IMU1" style="width:35%; height:auto;">
                          <img src="images/Lab2/p31.png" alt="Python_IMU2" style="width:65%; height:auto;">
                        </div>
                        <h5>As shown in earlier code, I decided to save the IMU data into seven separate float arrays. This approach
                          facilitates focused troubleshooting and calibration, enabling precise adjustments per sensor.
                          By transmitting data in discrete time steps, we can closely monitor the stream's integrity.</h5>
                        <h5>The choice of using float arrays is the balance between precision and memory. For IMU sensor data that requires
                          high precision, float or double should be used. The float array satisfies the precision needed at the cost of
                          using less memory than the double array.</h5>
                        <h5>The memory allocation is also carefully considered. With each data row consisting of 7 float
                           values, each requiring 4 bytes, we allocate 28 bytes per row.
                           An additional 88 bytes is reserved for the string ‘tx_estring_value’ that will be transmitted.
                           The Artemis with 384KB capacity would allow to store up to (384000-88)/28≈13711 rows of data. As shown in
                           the earlier code snippets, we've conservatively limited it to 5,000 rows within the ‘maxData’ variable.
                           This limitation not only prevents potential memory overflow but also permits a considerable window of data
                           collection, estimated to cover around 5000/310≈16 seconds. </h5>
                        <hr>
                        <h4>Record a Stunt</h4>
                        <h5>The car is disassembled for future labs, so the stunt simulation is conducted manually.
                          The battery is connected to the Artemis as shown below. </h5>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                          <img src="images/Lab2/p33.png" alt="remote" style="width:30%; height:auto;">
                        </div>
                        <h5>Holding the IMU, I executed movements that mimicked the anticipated actions of the car—moving it forward,
                          backward, and rotating in place. The resulting plot captures the accelerometer's readings along the
                          x, y, and z axes.</h5>
                        <div style="display: flex; justify-content: center; align-items: center;">
                          <img src="images/Lab2/p32.png" alt="stunt" style="width:50%; height:auto;">
                          <iframe width="560" height="315" src="https://www.youtube.com/embed/GCGroyWw844"
                          title="Temperature Readings" frameborder="0" allowfullscreen></iframe>
                        </div>
                        <hr>
                    </div>

                    <!-- Lab 3 content -->
                    <div id="lab3" class="lab-section">
                        <h2>Lab 3</h2>
                        <p>Content for Lab 3...</p>
                        <!-- ... more content for Lab 3 ... -->
                    </div>

                    <div id="lab4" class="lab-section">
                        <h2>Lab 4</h2>
                        <p>Content for Lab 4...</p>
                        <!-- ... more content for Lab 4 ... -->
                    </div>

                    <div id="lab5" class="lab-section">
                        <h2>Lab 5</h2>
                        <p>Content for Lab 5...</p>
                        <!-- ... more content for Lab 5 ... -->
                    </div>

                    <div id="lab6" class="lab-section">
                        <h2>Lab 6</h2>
                        <p>Content for Lab 6...</p>
                        <!-- ... more content for Lab 6 ... -->
                    </div>
                </div>
            </div>
        </div>
        <script
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js">
        </script>
        <script src="js/scripts.js"></script>
    </body>
</html>
